// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

model User {
  id             String   @id @default(cuid())
  email          String   @unique
  name           String?
  passwordHash   String
  defaultPercent Int      @default(10)
  locale         String   @default("he")
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  fixedCharities          FixedCharity[]
  incomes                 Income[]
  groupPaymentSnapshots   GroupPaymentSnapshot[]
  groupPaymentMemberships GroupPaymentMember[]
  sharedWith              SharedAccess[]         @relation("owner")
  sharedFrom              SharedAccess[]         @relation("viewer")
  partnershipsAsUser1     Partnership[]          @relation("partnership_user1")
  partnershipsAsUser2     Partnership[]          @relation("partnership_user2")
}

model FixedCharity {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  name      String
  amount    Int      // in agorot/cents for precision
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())

  @@index([userId])
}

model Income {
  id          String   @id @default(cuid())
  userId      String
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  month       String   // "2024-01" for queries
  amount      Int      // gross income (agorot)
  percentage  Int      // user's % at time of entry
  maaser      Int      // calculated: amount Ã— %
  description String?
  isFrozen    Boolean  @default(false) // frozen incomes cannot be edited/deleted
  createdAt   DateTime @default(now())

  @@index([userId, month])
}

model GroupPaymentSnapshot {
  id                       String   @id @default(cuid())
  month                    String   // "2024-12"
  groupOwnerId             String   // Who initiated payment
  groupOwner               User     @relation(fields: [groupOwnerId], references: [id], onDelete: Cascade)

  // Group financial totals
  totalGroupMaaser         Int      // Sum of all members' maaser
  totalGroupFixedCharities Int      // Sum of fixed charities (only for first payment per user)
  groupAmountPaid          Int      // Total amount paid by group

  // Member composition snapshot
  memberStates             Json     // [{userId, totalMaaser, fixedCharitiesTotal, unpaid}]

  // Many-to-many helper for efficient queries
  members                  GroupPaymentMember[]

  paidAt                   DateTime @default(now())
  createdAt                DateTime @default(now())

  @@index([groupOwnerId, month])
  @@index([month])
}

model GroupPaymentMember {
  id                      String                @id @default(cuid())
  groupPaymentSnapshotId  String
  groupPaymentSnapshot    GroupPaymentSnapshot  @relation(fields: [groupPaymentSnapshotId], references: [id], onDelete: Cascade)
  userId                  String
  user                    User                  @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@unique([groupPaymentSnapshotId, userId])
}

model SharedAccess {
  id         String   @id @default(cuid())
  ownerId    String
  owner      User     @relation("owner", fields: [ownerId], references: [id], onDelete: Cascade)
  viewerId   String
  viewer     User     @relation("viewer", fields: [viewerId], references: [id], onDelete: Cascade)
  canEdit    Boolean  @default(false)
  isSelected Boolean  @default(true)
  createdAt  DateTime @default(now())

  @@unique([ownerId, viewerId])
  @@index([ownerId])
  @@index([viewerId])
}

model Partnership {
  id          String            @id @default(cuid())
  user1Id     String
  user2Id     String
  status      PartnershipStatus @default(PENDING)
  initiatedBy String            // userId who created the invitation
  createdAt   DateTime          @default(now())
  updatedAt   DateTime          @updatedAt

  user1       User              @relation("partnership_user1", fields: [user1Id], references: [id], onDelete: Cascade)
  user2       User              @relation("partnership_user2", fields: [user2Id], references: [id], onDelete: Cascade)

  @@unique([user1Id, user2Id])
  @@index([user1Id])
  @@index([user2Id])
  @@index([status])
}

enum PartnershipStatus {
  PENDING
  ACCEPTED
  DECLINED
}
